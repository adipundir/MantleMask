# MantleMask Deployment Instructions

This document provides step-by-step instructions for deploying the MantleMask contracts using Remix IDE.

## Prerequisites

1. Access to [Remix IDE](https://remix.ethereum.org/)
2. MetaMask or another web3 wallet connected to Mantle Network
3. Some ETH on Mantle Network for gas fees

## Contract Overview

The MantleMask system consists of two main contracts:

1. **MantleMask.sol**: The main contract that handles deposits and withdrawals of native MNT. This contract includes the Merkle tree implementation for storing commitments.

2. **Verifier.sol**: A contract that verifies zero-knowledge proofs for private withdrawals.

## Deployment Steps

### Step 1: Import Contracts to Remix

Upload all the contract files to Remix:
- `MantleMask.sol`
- `Verifier.sol`
- `libraries/PoseidonT3.sol`

### Step 2: Install OpenZeppelin Contracts

In Remix, go to the "Plugin Manager" tab and activate the "Remixd" plugin. Then use the "File Explorers" tab to install OpenZeppelin contracts:

```bash
npm install @openzeppelin/contracts
```

### Step 3: Compile Contracts

1. Go to the "Solidity Compiler" tab
2. Select compiler version 0.8.20
3. Enable optimization with 200 runs
4. Compile each contract in the following order:
   - `PoseidonT3.sol`
   - `Verifier.sol`
   - `MantleMask.sol`

### Step 4: Deploy Contracts

Deploy the contracts in the following order:

#### 1. Deploy Verifier

1. Select `Verifier.sol` from the dropdown
2. Click "Deploy"
3. Save the deployed verifier address: `VERIFIER_ADDRESS`

#### 2. Deploy MantleMask

1. Select `MantleMask.sol` from the dropdown
2. Enter the following constructor parameters:
   - `_merkleTreeHeight`: `20` (recommended for production, use smaller values like 10 for testing)
   - `_verifier`: `VERIFIER_ADDRESS` (from step 1)
3. Click "Deploy"
4. Save the deployed MantleMask address: `MANTLEMASK_ADDRESS`

### Step 5: Verify Deployment

1. Test the MantleMask contract:
   - Call `deposit` with a commitment hash and send the appropriate amount of MNT (10, 100, 500, or 1000 MNT)
   - Verify the deposit was successful by checking the emitted events

## Implementation Notes

### Poseidon Hash Implementation

The `PoseidonT3.sol` library provides an efficient implementation of the Poseidon hash function that is compatible with zero-knowledge proofs. It includes:

1. A precompile-based implementation for chains that support Poseidon precompiles
2. A fallback pure Solidity implementation for chains without precompile support

### Verifier Implementation

The `Verifier.sol` contract implements verification of zero-knowledge proofs. In a production environment:

1. This contract would be generated by a ZK circuit compiler (like snarkjs or circom)
2. The verification key would be derived from the proving key used in the circuit
3. The verification would include proper pairing checks for the ZK proof

## Frontend Integration

To integrate with your frontend:

1. Update the frontend to use the deployed contract addresses
2. Generate commitments using the Poseidon hash function
3. Generate ZK proofs for withdrawals
4. Handle the note format properly

For example, to create a commitment:
```javascript
import { buildPoseidon } from "circomlibjs";

async function generateCommitment() {
  const poseidon = await buildPoseidon();
  const nullifier = generateSecureRandomField();
  const secret = generateSecureRandomField();
  const commitment = poseidon([nullifier, secret]);
  
  return {
    nullifier,
    secret,
    commitment: poseidon.F.toString(commitment)
  };
}
```

## Security Considerations

Before deploying to production, ensure:

1. A proper ZK circuit is implemented and tested
2. The Verifier contract is generated from this circuit
3. The Poseidon hash implementation is secure and efficient
4. The contracts have been professionally audited 